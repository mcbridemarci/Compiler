 //definitions
%{
#include <stdio.h>
#include <string.h>
#include "parser.tab.h" // this file will be auto generated by bison
#include "scanType.h"

extern int yylex();
//Count the lines
int line_num = 1;

static RType* rType;

void yyerror(const char *s);

%}

letter          [a-zA-Z]
digit           [0-9]
letdig          {letter}|{digit}
ID              {letter}+{letdig}*
NUMCONST        {digit}+
null            \0
newline         \n
CHARCONST       '[a-zA-Z0-9]|{null}|{newline}'


%%
 //rules section 
(\/\/)+.*$	; // Do nothing for comments @TODO what about new lines in comments 
[ \t]+           ; // Grab spaces and tabs and do nothing  
'\n'            { yylval.token=*newCHARtoken(); return CHARCONST; }
\n              { ++line_num; return ENDL; }
'\0'            { yylval.token=*newCHARtoken(); return CHARCONST;}

 

and             { yylval.token=*newKEYtoken(); return AND; }
or              { yylval.token=*newKEYtoken(); return OR; }
not             { yylval.token=*newKEYtoken(); return NOT; }

"<="            { yylval.token=*newKEYtoken(); return LESSEQ; }
">="            { yylval.token=*newKEYtoken(); return GRTEQ; }
={2}            { yylval.token=*newKEYtoken(); return EQ; }
!=              { yylval.token=*newKEYtoken(); return NOTEQ; }

\+\+            { yylval.token=*newKEYtoken(); return INC; }
--              { yylval.token=*newKEYtoken(); return DEC; }

\+=             { yylval.token=*newKEYtoken(); return ADDASS; }
-=              { yylval.token=*newKEYtoken(); return SUBASS; }
\*=             { yylval.token=*newKEYtoken(); return MULTASS; }
\/=             { yylval.token=*newKEYtoken(); return DIVASS; }

bool            { yylval.token=*newKEYtoken(); return BOOL; }
break           { yylval.token=*newKEYtoken(); return BREAK; }
char            { yylval.token=*newKEYtoken(); return CHAR; }
else            { yylval.token=*newKEYtoken(); return ELSE; }
if              { yylval.token=*newKEYtoken(); return IF; }
in              { yylval.token=*newKEYtoken(); return IN; }
int             { yylval.token=*newKEYtoken(); return INT; }
return          { yylval.token=*newKEYtoken(); return RETURN; }
while           { yylval.token=*newKEYtoken(); return WHILE; }
static          { yylval.token=*newKEYtoken(); return STATIC; }
true            { yylval.token=*newBOOLtoken(,,1); return BOOLCONST; }
false           { yylval.token=*newBOOLtoken(,,0); return BOOLCONST; }

[\(\)\{\}:;=,]  { return yytext[0]; }
[\*\/\+-<>\?]   { return yytext[0]; }
[\]\[%]         { return yytext[0]; }

{digit}+        { 
                  yylval.token=*newNUMtoken(,,strtoll(yytext)); 
                  return NUMCONST; 
                }

{ID}            { yylval.sval = strdup(yytext); return ID; }

{CHARCONST}       { yylval.token=*newCHARtoken(); return CHARCONST;}


.               { 
                  printf("Error(%d): Invalid or misplaced input character: "%s"\n", yytext);
                }

%%
 // user subroutine section 
 // No subroutine here because bison is taking care of it

